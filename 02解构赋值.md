## 数组的解构赋值
### 1、基本用法
只要符合一一匹配即可
```javascript
let arr = [1, 2, 3, 4, 5];
// ES5
var a = arr[0];
var b = arr[1];
var c = arr[2];
// ES6
let [a, b, c] = arr;
```
```javascript
let arr = [1, [2, [3, 4]]];
// ES5
var a = arr[0];
var b = arr[1][0];
var c = arr[1][1][0];
// ES6
let [a, [b, [c]]] = arr;
```
当不符合匹配模式时，解构失败，变量的值为`undefined`。
### 2、默认值
可以为变量指定默认值
```javascript
let [a, b = 2] = [1];
let [a = 1, b = a] = []; 
let [a = 1, b] = [2]; // 个人感觉这样写没有意义，除非这是一个稀疏数组
```
```javascript
let [a = b, b = 1] = []; // Uncaught ReferenceError: b is not defined
let [a = b, b = 2] = [1]; // a = 1; b = 2;
// 根据上可以得出，先解构匹配，后设置默认值
```
## 对象解构赋值
```javascript
var obj = {
    name: "zsq",
    age: 18
};
// ES5
var name = obj.name;
var age = obj.age;
// ES6
let {
    name,
    age
} = obj;
```
数组的解构是按顺序依次排序的，而对象，它是无序的键值对，所以变量名和属性名必须要相同。
```javascript
let {
    age,
    name
} = obj;
// age = 18; name = "zsq";
let {
    foo,
    bar,
    name
} = obj;
// foo = undefined; bar = undefined; name = "zsq";
```
如果变量名和属性名不一致,需要这样写。
```javascript
let {
    name: myName
} = obj;
// myName = "zsq";
```
所以，对象的解构赋值全写是这样。
```javascript
let {
    name: name,
    age: age
} = obj;
// 个人感觉，其实数组不也是这样的吗
```
因为`let`定义的变量在统一作用域内不可以二次定义，所以下面的代码会报错。
```javascript
let a;
let { a } = { a: 1 }; // Uncaught SyntaxError: Identifier 'a' has already been declared
```
然而，出于习惯，我们经常会这么写，为了解决错误，我们可以用`()`将代码包起来。
```javascript
let a;
({ a } = { a: 1});
```
**对象解构也可以嵌套**
```javascript
var response = {
    itemList: [
        { name: "qq", age: 18 },
        { name: "pp", age: 18 }
    ]
};

let { itemList: [pp, qq] } = response;
// pp = { name: "qq", age: 18 };
// qq = { name: "pp", age: 18 }
```
### 默认值
```javascript
let { name = 'zsq', age = 18 } = {};
let { name, age = 18} = { name: "zsq" };
let { name: myName = "zsq" } = {};
let { name: myName = "zsq" } = { name: "qq" };
```
